+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10/1000
, bws0 = bw
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "gaussian"
, adaptive = TRUE
, criterion = "dCVR"
)
?gwr.multiscale
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10/1000
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "gaussian"
, adaptive = TRUE
, criterion = "CVR"
)
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "gaussian"
, adaptive = TRUE
, criterion = "CVR"
)
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "gaussian"
, adaptive = TRUE
, criterion = "CVR"
)
# Model outputs
print(mgwr_results_dat_full)
# Model diagnostics
print(mgwr_results_dat_full$GW.diagnostic)
# Summary statistics of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
summary_stats <- apply(coefficients, 2, function(x) {
c(
min = round(min(x, na.rm = TRUE), 4),
q1 = round(quantile(x, 0.25, na.rm = TRUE), 4),
median = round(median(x, na.rm = TRUE), 4),
q3 = round(quantile(x, 0.75, na.rm = TRUE), 4),
max = round(max(x, na.rm = TRUE), 4),
sd = round(sd(x, na.rm = TRUE), 4)
)
})
summary_table <- data.frame(t(summary_stats))
print(summary_table)
# Boxplots of coefficients
melt_coefficients <- reshape2::melt(coefficients)
p2 <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
p2 <- p2 + geom_boxplot()
p2 <- p2 + labs(x = "", y = "Coefficient") + ggtitle("Boxplots of MGWR Coefficients")
p2 <- p2 + theme(axis.text.x = element_text(angle = 40, hjust = 1))
p2 <- p2 + geom_hline(yintercept = 0, linetype = "dashed", color = "red")
print(p2)
View(mgwr_results_dat_full)
summary(mgwr_results_dat_full$SDF)
?poly2nb
# Spatial autocorrelation
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE)
library(spdep)
# Spatial autocorrelation
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE)
nb
View(nb)
View(nb)
nb2listw?
?nb2listw
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
I <- moran(mgwr_results_dat_full$SDF$residual, lw, length(nb), Szero(lw))[1]
I
moran.test(mgwr_results_dat_full$SDF$residual, lw, alternative = "greater")
?moran.test
moran.test(mgwr_results_dat_full$SDF$residual, lw, alternative = "less")
moran.test(mgwr_results_dat_full$SDF$residual, lw, alternative = "two.sided")
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "two.sided"
, randomisation = TRUE
, zero.policy = TRUE
, rank = FALSE
, adjust.n = TRUE
)
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "two.sided"
, randomisation = TRUE
, zero.policy = TRUE
, rank = FALSE
, adjust.n = FALSE
)
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "two.sided"
, randomisation = TRUE
, zero.policy = TRUE
, rank = TRUE
, adjust.n = FALSE
)
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "two.sided"
, randomisation = TRUE
, zero.policy = FALSE
, rank = TRUE
, adjust.n = FALSE
)
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "two.sided"
, randomisation = FALSE
, zero.policy = FALSE
, rank = TRUE
, adjust.n = FALSE
)
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "greater"
, randomisation = FALSE
, zero.policy = FALSE
, rank = TRUE
, adjust.n = FALSE
)
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "greater")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two-sided")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 9999
, alternative = "two.sided")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 99999
, alternative = "two.sided")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 9999
, alternative = "two.sided")
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999999
, alternative = "two.sided")
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
# Installing libraries
# If you don't have any of the required packages installed, un-comment and run the necessary lines
# install.packages("rgdal")
# install.packages("GWmodel")
# install.packages("ggplot2")
# install.packages("GGally")
# install.packages("gridExtra")
# install.packages("tmap")
# install.packages("dplyr")
# install.packages("sf")
# install.packages("stringr")
# install.packages("tidyverse")
# install.packages("Hmisc")
# install.packages("reshape2")
# install.packages("car")
# install.packages("ellipse")
# install.packages("leaps")
# install.packages("nortest")
# Import libraries
#library(rgdal)
library(GWmodel)
library(ggplot2)
library(GGally)
library(gridExtra)
library(tmap)
library(dplyr)
library(sf)
library(stringr)
library(tidyverse)
library(Hmisc)
library(spdep)
source("plotting_functions.R")
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0)
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0)
plot(dat_tracts, col="#333333", lwd=0.25, border=0, max.plot = 1)
dat_tri <- read.csv('./Exposure/avgReleases_tract_CO_2008-2018.csv')
# Pad GEOID to 11 characters
dat_tri$GEOID10 <- str_pad(dat_tri$GEOID10, width = 11, side = "left", pad = 0)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
# Installing libraries
# If you don't have any of the required packages installed, un-comment and run the necessary lines
# install.packages("rgdal")
# install.packages("GWmodel")
# install.packages("ggplot2")
# install.packages("GGally")
# install.packages("gridExtra")
# install.packages("tmap")
# install.packages("dplyr")
# install.packages("sf")
# install.packages("stringr")
# install.packages("tidyverse")
# install.packages("Hmisc")
# install.packages("reshape2")
# install.packages("car")
# install.packages("ellipse")
# install.packages("leaps")
# install.packages("nortest")
# Import libraries
#library(rgdal)
library(GWmodel)
library(ggplot2)
library(GGally)
library(gridExtra)
library(tmap)
library(dplyr)
library(sf)
library(stringr)
library(tidyverse)
library(Hmisc)
library(spdep)
source("plotting_functions.R")
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0, max.plot = 1)
dat_tri <- read.csv('./Exposure/avgReleases_tract_CO_2008-2018.csv')
# Pad GEOID to 11 characters
dat_tri$GEOID10 <- str_pad(dat_tri$GEOID10, width = 11, side = "left", pad = 0)
svi <- read.csv('./Confounders/SVI_2018_US.csv') # SVI data for all census tracts in US
svi$FIPS <- str_pad(svi$FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
# unique(nchar(svi$FIPS))
svi_sub <- svi %>%
filter(ST_ABBR %in% c("CO")) # Subset SVI to only include tracts in Colorado
svi_sub[svi_sub == -999] <- NA # Missing values are coded as -999, here we replace -999 with NA
# Keep percentage, percentile, theme ranking, flag variables, and total population
svi_sub <- svi_sub %>%
dplyr::select(FIPS, starts_with(c("E_TOTPOP", "EP_", "EPL_", "SPL_", "RPL", "F_")))
outcome <- read.csv('./Outcome/CDPHE_Composite_Selected_Health_Outcome_Dataset_(Census_Tract).csv')
lwb <- outcome[, c(2, 26:32)] # Subset to only include low birthweight variables and GEOID
lwb$TRACT_FIPS <- str_pad(lwb$TRACT_FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
# Combine data tables
# Join data using the dplyr library - this doesn't work on SpatialPolygonDataFrame data types, so convert first
dat_full <- st_as_sf(dat_tracts)
dat_full <- dat_full %>%
right_join(dat_tri, by = c("GEOID10" = "GEOID10")) %>% # Exposure
right_join(lwb, by = c("GEOID10" = "TRACT_FIPS")) %>% # Outcome
right_join(svi_sub, by = c("GEOID10" = "FIPS")) # Confounders
# Create a subset for global models
global_dat <- dat_full %>%
select(GEOID10, avgReleasesLb_10yr, LWB_ADJRATE, E_TOTPOP, starts_with("EP_")) # Keep total population estimate (E_TOTPOT) and land area (ALAND10) for later reference
global_dat <-
data.frame(global_dat[, 1:20]
)
# %>% # To only keep certain observations, uncomment this line and move the pipe (%>%) up to the line above
#   # Only retain observations we're analyzing
#   slice(
#     -659
#   )
dat_full <- as(na.omit(dat_full), "Spatial") # Convert dat_full back to spatial - we will use this for the spatial models
summary(dat_full)
# fit full model
lm_full <- lm(LWB_ADJRATE ~ avgReleasesLb_10yr + EP_POV + EP_UNEMP + EP_PCI + EP_NOHSDP + EP_AGE65 + EP_AGE17 + EP_DISABL
+ EP_SNGPNT + EP_MINRTY + EP_LIMENG + EP_MUNIT + EP_MOBILE + EP_CROWD
+ EP_NOVEH + EP_GROUPQ + EP_UNINSUR
, data = global_dat)
summary(lm_full)
## Backward selection using model AIC
lm_red_AIC <- step(lm_full, direction="backward", test="F")
lm_final <- lm_red_AIC
summary(lm_final)
# Plot correlation matrix of variables from the reduced model
vars <- c(
"avgReleasesLb_10yr", "EP_POV", "EP_UNEMP", "EP_PCI",
"EP_NOHSDP", "EP_AGE17", "EP_DISABL", "EP_MINRTY",
"EP_GROUPQ", "EP_UNINSUR"
)
# Create a subset of 'global_dat' with selected variables
global_dat_sub <- global_dat[, c("LWB_ADJRATE", vars)]
# Plot the correlation matrix using ggpairs
p <- ggpairs(
global_dat_sub,
upper = list(continuous = wrap("points", alpha = 0.2, size = 0.5)),
lower = list(continuous = "cor")
)
print(p)
# plot diagnostics
lm_diag_plots(lm_red_AIC, sw_plot_set = "simpleAV")
# To do: Spatial autocorrelation
# Calculate distance matrix
DM <- gw.dist(dp.locat = coordinates(dat_full))
# Define optimal bandwidths for GWR
bw <- bw.gwr(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, approach = "CV"
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE
, dMat = DM)
# Basic GWR
gwr_results_dat <- gwr.basic(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10
, data = dat_full
, bw = bw
, dMat = DM
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE)
# Model diagnostics
gwr_results_dat$GW.diagnostic
# Spatial autocorrelation
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, max.iterations = 100 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "gaussian"
, adaptive = TRUE
, criterion = "CVR"
)
# Model outputs
print(mgwr_results_dat_full)
# Model diagnostics
print(mgwr_results_dat_full$GW.diagnostic)
# Spatial autocorrelation
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
I <- moran(mgwr_results_dat_full$SDF$residual, lw, length(nb), Szero(lw))[1]
I
moran.test(mgwr_results_dat_full$SDF$residual
, lw
, alternative = "greater"
, randomisation = FALSE
, zero.policy = FALSE
, rank = TRUE
, adjust.n = FALSE
)
moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
moran_mgwr <- moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
moran_mgwr$statistic
moran_mgwr$p.value
# Summary statistics of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
# Summary statistics of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
summary_stats <- apply(coefficients, 2, function(x) {
c(
min = round(min(x, na.rm = TRUE), 4),
q1 = round(quantile(x, 0.25, na.rm = TRUE), 4),
median = round(median(x, na.rm = TRUE), 4),
q3 = round(quantile(x, 0.75, na.rm = TRUE), 4),
max = round(max(x, na.rm = TRUE), 4),
sd = round(sd(x, na.rm = TRUE), 4)
)
})
summary_table <- data.frame(t(summary_stats))
print(summary_table)
# Boxplots of coefficients
melt_coefficients <- reshape2::melt(coefficients)
p2 <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
p2 <- p2 + geom_boxplot()
p2 <- p2 + labs(x = "", y = "Coefficient") + ggtitle("Boxplots of MGWR Coefficients")
p2 <- p2 + theme(axis.text.x = element_text(angle = 40, hjust = 1))
p2 <- p2 + geom_hline(yintercept = 0, linetype = "dashed", color = "red")
print(p2)
# Map coefficients
p1m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
p2m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "avgReleasesLb_10yr", mgwr_results_dat_full$SDF$avgReleasesLb_10yr_TV)
p3m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_POV", mgwr_results_dat_full$SDF$EP_POV_TV)
p4m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_PCI", mgwr_results_dat_full$SDF$EP_PCI_TV)
p5m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_NOHSDP", mgwr_results_dat_full$SDF$EP_NOHSDP_TV)
p6m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_AGE17", mgwr_results_dat_full$SDF$EP_AGE17_TV)
p7m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_DISABL", mgwr_results_dat_full$SDF$EP_DISABL_TV)
p8m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_MINRTY", mgwr_results_dat_full$SDF$EP_MINRTY_TV)
p9m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_GROUPQ", mgwr_results_dat_full$SDF$EP_GROUPQ_TV)
p10m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNINSUR", mgwr_results_dat_full$SDF$EP_UNINSUR_TV)
p11m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNEMP", mgwr_results_dat_full$SDF$EP_UNEMP_TV)
p_mgwr <- tmap_arrange(p1m
, p2m
, p3m
, p4m
, p5m
, p6m
, p7m
, p8m
, p9m
, p10m
, p11m
, ncol = 2)
print(p_mgwr)
# Spatial autocorrelation of basic GWR residuals
nb <- poly2nb(gwr_results_dat$SDF$residual, queen = TRUE) # Define neighbors for each polygon
View(gwr_results_dat)
summary(gwr_results_dat$SDF)
View(mgwr_results_dat_full)
# Spatial autocorrelation of MGWR residuals
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE) # Define neighbors for each polygon
# Spatial autocorrelation of basic GWR residuals
nb <- poly2nb(gwr_results_dat$SDF$residual, queen = TRUE) # Define neighbors for each polygon
# Spatial autocorrelation of basic GWR residuals
gwr_results_dat$SDF <- as( , "Spatial")
# Spatial autocorrelation of basic GWR residuals
gwr_results <- as(gwr_results_dat$SDF, "Spatial")
nb <- poly2nb(gwr_results_dat$SDF$residual, queen = TRUE) # Define neighbors for each polygon
View(gwr_results)
nb <- poly2nb(as(gwr_results_dat$SDF$residual, "Spatial"), queen = TRUE) # Define neighbors for each polygon
summary(gwr_results_dat$SDF$residual)
# Spatial autocorrelation of basic GWR residuals
nb <- poly2nb(gwr_results_dat$SDF$residual, queen = TRUE) # Define neighbors for each polygon
View(gwr_results_dat)
# Spatial autocorrelation of basic GWR residuals
#
nb <- poly2nb(gwr_results_dat$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_gwr <- moran.mc(gwr_results_dat$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
moran_gwr$statistic
moran_gwr$p.value
