# Plot the correlation matrix using ggpairs
p_cor <- ggpairs(
global_dat_sub,
upper = list(continuous = wrap("points", alpha = 0.2, size = 0.5)),
lower = list(continuous = "cor")
)
print(p_cor)
# plot diagnostics
lm_diag_plots(lm_red_AIC, sw_plot_set = "simpleAV")
# Spatial autocorrelation of global linear model residuals
lm_resid_col <- lm_red_AIC$residuals # Make data table of residuals from lm_red_AIC
dat_full$residuals <- lm_resid_col[as.character(rownames(dat_full@data))] # Append residuals to dat_full by row name
nb <- poly2nb(dat_full, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_lm <- moran.mc(dat_full$residuals
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_lm$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_lm$p.value))
# Calculate distance matrix
DM <- gw.dist(dp.locat = coordinates(dat_full))
?bw.gwr
# Define optimal bandwidths for GWR
bw <- bw.gwr(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, approach = "CV"
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE
, dMat = DM)
# Basic GWR
gwr_results_dat <- gwr.basic(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10
, data = dat_full
, bw = bw
, dMat = DM
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE)
gwr_results_dat
# Model diagnostics
gwr_results_dat$GW.diagnostic
?poly2nb
?nb2listw
# Spatial autocorrelation of basic GWR residuals
nb <- poly2nb(gwr_results_dat$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_gwr <- moran.mc(gwr_results_dat$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_gwr$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_gwr$p.value))
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
# , kernel = "gaussian" # wgt = exp(-.5*(vdist/bw)^2);
, kernel = "exponential" # wgt = exp(-vdist/bw);
# , kernel = "bisquare" # wgt = (1-(vdist/bw)^2)^2 if vdist < bw, wgt=0 otherwise;
# , kernel = "tricube" # wgt = (1-(vdist/bw)^3)^3 if vdist < bw, wgt=0 otherwise;
# , kernel = "boxcar" # wgt=1 if dist < bw, wgt=0 otherwise
, adaptive = TRUE
, criterion = "CVR"
)
# Model outputs
print(mgwr_results_dat_full)
# Model diagnostics
print(mgwr_results_dat_full$GW.diagnostic)
# Spatial autocorrelation of MGWR residuals
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_mgwr <- moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_mgwr$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_mgwr$p.value))
View(gwr_results_dat)
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"))
# Print the map
print(p)
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE)
# Print the map
print(p)
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE) +
tm_title("GWR Results")
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE) +
tm_add_title("GWR Results")
# Create a map with polygons shaded by the 'Local_R2' values
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE, title = "GWR Results")
# Print the map
print(p)
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE, title = "GWR Resultkdshaf;khjasdf;khjasfd;hjasdfs")
# Print the map
print(p)
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"), legend.outside = TRUE, title = "GWR Results", title.position = c("center", "top"))
# Print the map
print(p)
# Set tmap options
tmap_options(max.res = 300, layout.show.legend = TRUE)
# Set tmap options
tmap_mode("plot")
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE,
title = "GWR Results",
title.position = c("center", "top"))
# Print the map
print(p)
# Set tmap options
tmap_mode("plot")
# Create a map with polygons shaded by the 'Local_R2' values
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE,
# title = "GWR Results",
# title.position = c("center", "top")
)
# Print the map
print(p)
# Set tmap options
# tmap_mode("plot")
p <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE,
)
# Print the map
print(p)
# Plot local R2
p_gwr <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE
)
print(p_gwr)
# Plot local R2
p_gwr <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE
)
print(p_gwr)
# Plot local R2
p_gwr <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE
)
print(p_gwr)
# Boxplots of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
melt_coefficients <- reshape2::melt(coefficients)
p_mgwr_bp <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
p_mgwr_bp <- p_mgwr_bp + geom_boxplot()
p_mgwr_bp <- p_mgwr_bp + labs(x = "", y = "Coefficient") + ggtitle("Boxplots of MGWR Coefficients")
p_mgwr_bp <- p_mgwr_bp + theme(axis.text.x = element_text(angle = 40, hjust = 1))
p_mgwr_bp <- p_mgwr_bp + geom_hline(yintercept = 0, linetype = "dashed", color = "red")
print(p_mgwr_bp)
# Boxplots of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
melt_coefficients <- reshape2::melt(coefficients)
p_mgwr_bp <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
p_mgwr_bp <- p_mgwr_bp + geom_boxplot()
p_mgwr_bp <- p_mgwr_bp + labs(x = "", y = "Coefficient") + ggtitle("Boxplots of MGWR Coefficients")
p_mgwr_bp <- p_mgwr_bp + theme(axis.text.x = element_text(angle = 40, hjust = 1))
p_mgwr_bp <- p_mgwr_bp + geom_hline(yintercept = 0, linetype = "dashed", color = "red")
print(p_mgwr_bp)
# Map coefficients
p1_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
p2_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "avgReleasesLb_10yr", mgwr_results_dat_full$SDF$avgReleasesLb_10yr_TV)
p3_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_POV", mgwr_results_dat_full$SDF$EP_POV_TV)
p4_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_PCI", mgwr_results_dat_full$SDF$EP_PCI_TV)
p5_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_NOHSDP", mgwr_results_dat_full$SDF$EP_NOHSDP_TV)
p6_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_AGE17", mgwr_results_dat_full$SDF$EP_AGE17_TV)
p7_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_DISABL", mgwr_results_dat_full$SDF$EP_DISABL_TV)
p8_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_MINRTY", mgwr_results_dat_full$SDF$EP_MINRTY_TV)
p9_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_GROUPQ", mgwr_results_dat_full$SDF$EP_GROUPQ_TV)
p10_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNINSUR", mgwr_results_dat_full$SDF$EP_UNINSUR_TV)
p11_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNEMP", mgwr_results_dat_full$SDF$EP_UNEMP_TV)
p_mgwr <- tmap_arrange(p1_mgwr
, p2_mgwr
, p3_mgwr
, p4_mgwr
, p5_mgwr
, p6_mgwr
, p7_mgwr
, p8_mgwr
, p9_mgwr
, p10_mgwr
, p11_mgwr
, ncol = 2)
print(p_mgwr)
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0, max.plot = 1)
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0, max.plot = 1)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
# Map coefficients
p1_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
## Installing libraries
## If you don't have any of the required packages installed, un-comment and run the necessary lines
# install.packages("rgdal")
# install.packages("GWmodel")
# install.packages("ggplot2")
# install.packages("GGally")
# install.packages("gridExtra")
# install.packages("tmap")
# install.packages("dplyr")
# install.packages("sf")
# install.packages("stringr")
# install.packages("tidyverse")
# install.packages("Hmisc")
# install.packages('car')
# install.packages('Rtools')
# install.packages('nortest')
# install.packages("reshape2")
# install.packages("car")
# install.packages("ellipse")
# install.packages("leaps")
# install.packages("nortest")
# Import libraries
library(GWmodel)
library(ggplot2)
library(GGally)
library(gridExtra)
library(tmap)
library(dplyr)
library(sf)
library(stringr)
library(tidyverse)
library(Hmisc)
library(car)
library(nortest)
library(spdep)
source("plotting_functions.R")
# Import shapefile
dat_tracts <- st_read(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0, max.plot = 1)
dat_tri <- read.csv('./Exposure/avgReleases_tract_popCenter_50km_CO_2008-2018.csv')
# Pad GEOID to 11 characters
dat_tri$GEOID10 <- str_pad(dat_tri$GEOID10, width = 11, side = "left", pad = 0)
# unique(nchar(dat_tri$GEOID10)) # Un-comment this line if you want to check if padding worked
svi <- read.csv('./Confounders/SVI_2018_US.csv') # SVI data for all census tracts in US
svi$FIPS <- str_pad(svi$FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
# unique(nchar(svi$FIPS))
svi_sub <- svi %>%
filter(ST_ABBR %in% c("CO")) # Subset SVI to only include tracts in Colorado
svi_sub[svi_sub == -999] <- NA # Missing values are coded as -999, here we replace -999 with NA
# Keep percentage, percentile, theme ranking, flag variables, and total population
svi_sub <- svi_sub %>%
dplyr::select(FIPS, starts_with(c("E_TOTPOP", "EP_", "EPL_", "SPL_", "RPL", "F_")))
# unique(nchar(svi_sub$FIPS))
outcome <- read.csv('./Outcome/CDPHE_Composite_Selected_Health_Outcome_Dataset_(Census_Tract).csv')
lwb <- outcome[, c(2, 26:32)] # Subset to only include low birthweight variables and GEOID
lwb$TRACT_FIPS <- str_pad(lwb$TRACT_FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
# unique(nchar(lwb$TRACT_FIPS))
# Combine data tables
# Join data using the dplyr library - this doesn't work on SpatialPolygonDataFrame data types, so convert first
dat_full <- st_as_sf(dat_tracts)
dat_full <- dat_full %>%
right_join(dat_tri, by = c("GEOID10" = "GEOID10")) %>% # Exposure
right_join(lwb, by = c("GEOID10" = "TRACT_FIPS")) %>% # Outcome
right_join(svi_sub, by = c("GEOID10" = "FIPS")) # Confounders
# Create a subset for global models
global_dat <- dat_full %>%
select(GEOID10, avgReleasesLb_10yr, LWB_ADJRATE, E_TOTPOP, starts_with("EP_")) # Keep total population estimate (E_TOTPOT) and land area (ALAND10) for later reference
global_dat <-
data.frame(global_dat[, 1:20]
)
# %>% # To only keep certain observations, uncomment this line and move the pipe (%>%) up to the line above
#   # Only retain observations we're analyzing
#   slice(
#     -659
#   )
dat_full <- as(na.omit(dat_full), "Spatial") # Convert dat_full back to spatial - we will use this for the spatial models
summary(dat_full)
# fit full model
lm_full <- lm(LWB_ADJRATE ~ avgReleasesLb_10yr + EP_POV + EP_UNEMP + EP_PCI + EP_NOHSDP + EP_AGE65 + EP_AGE17 + EP_DISABL + EP_SNGPNT + EP_MINRTY + EP_LIMENG + EP_MUNIT + EP_MOBILE + EP_CROWD + EP_NOVEH + EP_GROUPQ + EP_UNINSUR
, data = global_dat)
summary(lm_full)
## Backward selection using model AIC
lm_red_AIC <- step(lm_full, direction="backward", test="F")
lm_final <- lm_red_AIC
summary(lm_final)
# Plot correlation matrix of variables from the reduced model
vars <- c(
"avgReleasesLb_10yr", "EP_POV", "EP_UNEMP",
"EP_PCI", "EP_NOHSDP", "EP_AGE17", "EP_DISABL", "EP_MINRTY", "EP_MOBILE",
"EP_GROUPQ", "EP_UNINSUR"
)
# Create a subset of 'global_dat' with selected variables
global_dat_sub <- global_dat[, c("LWB_ADJRATE", vars)]
# Plot the correlation matrix using ggpairs
p_cor <- ggpairs(
global_dat_sub,
upper = list(continuous = wrap("points", alpha = 0.2, size = 0.5)),
lower = list(continuous = "cor")
)
print(p_cor)
# plot diagnostics
lm_diag_plots(lm_red_AIC, sw_plot_set = "simpleAV")
# Spatial autocorrelation of global linear model residuals
lm_resid_col <- lm_red_AIC$residuals # Make data table of residuals from lm_red_AIC
dat_full$residuals <- lm_resid_col[as.character(rownames(dat_full@data))] # Append residuals to dat_full by row name
nb <- poly2nb(dat_full, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_lm <- moran.mc(dat_full$residuals
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_lm$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_lm$p.value))
# Calculate distance matrix
DM <- gw.dist(dp.locat = coordinates(dat_full))
# Define optimal bandwidths for GWR
bw <- bw.gwr(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, approach = "CV"
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE
, dMat = DM)
# Basic GWR
gwr_results_dat <- gwr.basic(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
+ ALAND10
, data = dat_full
, bw = bw
, dMat = DM
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE)
gwr_results_dat
# Model diagnostics
gwr_results_dat$GW.diagnostic
# Spatial autocorrelation of basic GWR residuals
nb <- poly2nb(gwr_results_dat$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_gwr <- moran.mc(gwr_results_dat$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_gwr$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_gwr$p.value))
# Plot local R2
p_gwr <- tm_shape(gwr_results_dat$SDF) +
tm_polygons("Local_R2", palette = "RdYlBu", title = "Local R2") +
tm_layout(legend.position = c("right", "bottom"),
legend.outside = TRUE
)
print(p_gwr)
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, max.iterations = 1 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
# , kernel = "gaussian" # wgt = exp(-.5*(vdist/bw)^2);
, kernel = "exponential" # wgt = exp(-vdist/bw);
# , kernel = "bisquare" # wgt = (1-(vdist/bw)^2)^2 if vdist < bw, wgt=0 otherwise;
# , kernel = "tricube" # wgt = (1-(vdist/bw)^3)^3 if vdist < bw, wgt=0 otherwise;
# , kernel = "boxcar" # wgt=1 if dist < bw, wgt=0 otherwise
, adaptive = TRUE
, criterion = "CVR"
)
# Model outputs
print(mgwr_results_dat_full)
# Model diagnostics
print(mgwr_results_dat_full$GW.diagnostic)
# Spatial autocorrelation of MGWR residuals
nb <- poly2nb(mgwr_results_dat_full$SDF, queen = TRUE) # Define neighbors for each polygon
lw <- nb2listw(nb, style = "U", zero.policy = TRUE) # Assign weights to neighbors
moran_mgwr <- moran.mc(mgwr_results_dat_full$SDF$residual
, lw
, nsim = 999
, alternative = "two.sided")
print(rbind("Moran's I statistic: " ,moran_mgwr$statistic))
print(rbind("P-value of Moran's I statistic: ", moran_mgwr$p.value))
# Boxplots of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
melt_coefficients <- reshape2::melt(coefficients)
p_mgwr_bp <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
p_mgwr_bp <- p_mgwr_bp + geom_boxplot()
p_mgwr_bp <- p_mgwr_bp + labs(x = "", y = "Coefficient") + ggtitle("Boxplots of MGWR Coefficients")
p_mgwr_bp <- p_mgwr_bp + theme(axis.text.x = element_text(angle = 40, hjust = 1))
p_mgwr_bp <- p_mgwr_bp + geom_hline(yintercept = 0, linetype = "dashed", color = "red")
print(p_mgwr_bp)
# Map coefficients
p1_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
p2_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "avgReleasesLb_10yr", mgwr_results_dat_full$SDF$avgReleasesLb_10yr_TV)
p3_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_POV", mgwr_results_dat_full$SDF$EP_POV_TV)
p4_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_PCI", mgwr_results_dat_full$SDF$EP_PCI_TV)
p5_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_NOHSDP", mgwr_results_dat_full$SDF$EP_NOHSDP_TV)
p6_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_AGE17", mgwr_results_dat_full$SDF$EP_AGE17_TV)
p7_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_DISABL", mgwr_results_dat_full$SDF$EP_DISABL_TV)
p8_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_MINRTY", mgwr_results_dat_full$SDF$EP_MINRTY_TV)
p9_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_GROUPQ", mgwr_results_dat_full$SDF$EP_GROUPQ_TV)
p10_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNINSUR", mgwr_results_dat_full$SDF$EP_UNINSUR_TV)
p11_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "EP_UNEMP", mgwr_results_dat_full$SDF$EP_UNEMP_TV)
p_mgwr <- tmap_arrange(p1_mgwr
, p2_mgwr
, p3_mgwr
, p4_mgwr
, p5_mgwr
, p6_mgwr
, p7_mgwr
, p8_mgwr
, p9_mgwr
, p10_mgwr
, p11_mgwr
, ncol = 2)
print(p_mgwr)
print(p_mgwr)
# Map coefficients
p1_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
p1_mgwr
p2_mgwr <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "avgReleasesLb_10yr", mgwr_results_dat_full$SDF$avgReleasesLb_10yr_TV)
p2_mgwr
p2_mgwr
