knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = FALSE)
# Import libraries
library(rgdal)
library(GWmodel)
# Import shapefile
dat_tracts <- readOGR(dsn = "./Tracts/tl_2010_08_tract10.shp")
# Plot shapefile with base R - this is just to check that it renders correctly
par(mar=c(0,0,0,0))
plot(dat_tracts, col="#333333", lwd=0.25, border=0)
dat_tri <- read.csv('./Exposure/avgReleases_tract_CO_2008-2018.csv')
# Pad GEOID to 11 characters
dat_tri$GEOID10 <- str_pad(dat_tri$GEOID10, width = 11, side = "left", pad = 0)
svi <- read.csv('./Confounders/SVI_2018_US.csv') # SVI data for all census tracts in US
svi$FIPS <- str_pad(svi$FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
outcome <- read.csv('./Outcome/CDPHE_Composite_Selected_Health_Outcome_Dataset_(Census_Tract).csv')
lwb <- outcome[, c(2, 26:32)] # Subset to only include low birthweight variables and GEOID
lwb$TRACT_FIPS <- str_pad(lwb$TRACT_FIPS, width = 11, side = "left", pad = 0) # Pad GEOIDs so that they are all 11 characters long
# Combine data tables
# Join data using the dplyr library - this doesn't work on SpatialPolygonDataFrame data types, so convert first
dat_full <- st_as_sf(dat_tracts)
dat_full <- dat_full %>%
right_join(dat_tri, by = c("GEOID10" = "GEOID10")) %>% # Exposure
right_join(lwb, by = c("GEOID10" = "TRACT_FIPS")) %>% # Outcome
right_join(svi_sub, by = c("GEOID10" = "FIPS")) # Confounders
# fit full model
lm_full <- lm(LWB_ADJRATE ~ avgReleasesLb_10yr + EP_POV + EP_UNEMP + EP_PCI + EP_NOHSDP + EP_AGE65 + EP_AGE17 + EP_DISABL
+ EP_SNGPNT + EP_MINRTY + EP_LIMENG + EP_MUNIT + EP_MOBILE + EP_CROWD
+ EP_NOVEH + EP_GROUPQ + EP_UNINSUR
, data = global_dat)
## Backward selection using model AIC
lm_red_AIC <- step(lm_full, direction="backward", test="F")
# Plot correlation matrix of variables from the reduced model
vars <- c(
"avgReleasesLb_10yr", "EP_POV", "EP_UNEMP", "EP_PCI",
"EP_NOHSDP", "EP_AGE17", "EP_DISABL", "EP_MINRTY",
"EP_GROUPQ", "EP_UNINSUR"
)
# Create a subset of 'global_dat' with selected variables
global_dat_sub <- global_dat[, c("LWB_ADJRATE", vars)]
# plot diagnostics
lm_diag_plots(lm_red_AIC, sw_plot_set = "simpleAV")
# To do: Spatial autocorrelation
# Calculate distance matrix
DM <- gw.dist(dp.locat = coordinates(dat_full))
# Define optimal bandwidths for GWR
bw <- bw.gwr(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
# + ALAND10 # This makes the model get stuck for some reason
, data = dat_full
, approach = "AICc"
, kernel = "gaussian"
, adaptive = TRUE
, longlat = TRUE
, dMat = DM)
# Basic GWR
gwr_results_dat <- gwr.basic(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
, data = dat_full
, bw = bw
, dMat = DM
, kernel = "bisquare"
, adaptive = TRUE
, longlat = TRUE)
# Spatial autocorrelation
# Multiscale geographically weighted regression
# Documentation: https://search.r-project.org/CRAN/refmans/GWmodel/html/gwr.multiscale.html
mgwr_results_dat_full <- gwr.multiscale(LWB_ADJRATE ~ avgReleasesLb_10yr
+ EP_POV
+ EP_UNEMP
+ EP_PCI
+ EP_NOHSDP
+ EP_AGE17
+ EP_DISABL
+ EP_MINRTY
+ EP_GROUPQ
+ EP_UNINSUR
# + ALAND10
, data = dat_full
, max.iterations = 2 # Set max iterations higher to optimize model - it's at 2 now to minimize computational burden
, kernel = "bisquare"
, adaptive = TRUE
, criterion = "dCVR"
)
# Spatial autocorrelation
#Plot neighborhood sizes (bandwidths)
# Summary statistics of coefficients
coefficients <- data.frame(mgwr_results_dat_full$SDF[, 2:11])
# Boxplots of coefficients
melt_coefficients <- reshape2::melt(coefficients)
p2 <- ggplot(melt_coefficients, aes(x = fct_reorder(variable, value, .fun = mean), y = value))
# Map coefficients
p1m <- plot.gwr.coefs(mgwr_results_dat_full$SDF, "Intercept", mgwr_results_dat_full$SDF$Intercept_TV)
